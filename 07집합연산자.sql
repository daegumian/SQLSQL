--집합연산자
--UNION - 합집합, UNION ALL - 합집합, INTERSECT - 교집합, MINUS - 차집합

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; -- 미쉘이 중복이기 때문에, 중복제거 <많이 사용>

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
UNION ALL
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; -- 미쉘이 중복이여도 함께 출력 <많이 사용> 

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
INTERSECT
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; -- 교집합만 출력

SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE HIRE_DATE LIKE '04%'
MINUS
SELECT FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE DEPARTMENT_ID = 20; -- A-B 결과 출력

--집합연산자는 컬럼수가 일치해야함
--컬럼 수가 일치한다면, 다양한 형태로 사용이 된다.
SELECT '홍길동', TO_CHAR(SYSDATE) FROM DUAL
UNION ALL
SELECT '이순신', '88/01/01' FROM DUAL
UNION ALL
SELECT '홍길자', '99/04/23' FROM DUAL
UNION ALL
SELECT LAST_NAME, TO_CHAR(HIRE_DATE) FROM EMPLOYEES;

-------------------------------------------------------------------------------------------
--분석함수 - 행에 대한 결과를 출력하는 기능, OVER()와 함께 사용.
SELECT FIRST_NAME,
                SALARY, 
                RANK() OVER(ORDER BY SALARY DESC) AS 중복순서,
                DENSE_RANK() OVER(ORDER BY SALARY DESC) AS 중복순서X,
                ROW_NUMBER() OVER(ORDER BY SALARY DESC) AS 데이터번호, --데이터의 번호
                COUNT(*) OVER(ORDER BY SALARY DESC) AS 전체데이터갯수,
                ROWNUM AS 조회순서 -- 조회가 일어난 순서
FROM EMPLOYEES ;


